/**
 * @file
 * @brief Function prototypes for the new opcode functions.
 * @note  DO NOT EDIT THIS FILE, your changes will be lost.
 *        Edit libfirm/ir/be/sparc/sparc_spec.pl instead.
 *        created by: libfirm/ir/be/scripts/generate_new_opcodes.pl libfirm/ir/be/sparc/sparc_spec.pl libfirm/ir/be/sparc
 * @date  Tue Dec 15 15:19:15 2009
 */
#ifndef FIRM_BE_SPARC_GEN_SPARC_NEW_NODES_H
#define FIRM_BE_SPARC_GEN_SPARC_NEW_NODES_H

typedef enum _sparc_opcodes {
	iro_sparc_SubSP,
	iro_sparc_Add,
	iro_sparc_FrameAddr,
	iro_sparc_Store,
	iro_sparc_Branch,
	iro_sparc_Mov,
	iro_sparc_Tst,
	iro_sparc_SwitchJmp,
	iro_sparc_Cmp,
	iro_sparc_SymConst,
	iro_sparc_Sub,
	iro_sparc_Load,
	iro_sparc_AddSP,
	iro_sparc_last_generated,
	iro_sparc_last = iro_sparc_last_generated
} sparc_opcodes;

int is_sparc_irn(const ir_node *node);

int get_sparc_opcode_first(void);
int get_sparc_opcode_last(void);
int get_sparc_irn_opcode(const ir_node *node);
void sparc_create_opcodes(const arch_irn_ops_t *be_ops);
extern ir_op *op_sparc_SubSP;
ir_op *get_op_sparc_SubSP(void);
int is_sparc_SubSP(const ir_node *n);
/**
 * free stack space
 */
ir_node *new_bd_sparc_SubSP(dbg_info *dbgi, ir_node *block, ir_node *stack, ir_node *size, ir_node *mem);

extern ir_op *op_sparc_Add;
ir_op *get_op_sparc_Add(void);
int is_sparc_Add(const ir_node *n);
/**
 * construct Add node
 */
ir_node *new_bd_sparc_Add_imm(dbg_info *dbgi, ir_node *block, ir_node *left, int immediate_value);
/**
 * construct Add node
 */
ir_node *new_bd_sparc_Add_reg(dbg_info *dbgi, ir_node *block, ir_node *left, ir_node *right);

extern ir_op *op_sparc_FrameAddr;
ir_op *get_op_sparc_FrameAddr(void);
int is_sparc_FrameAddr(const ir_node *n);
/**
 * construct FrameAddr node
 */
ir_node *new_bd_sparc_FrameAddr(dbg_info *dbgi, ir_node *block, ir_node *base, ir_entity *entity);

extern ir_op *op_sparc_Store;
ir_op *get_op_sparc_Store(void);
int is_sparc_Store(const ir_node *n);
/**
 * construct Store: Store(ptr, val, mem) = ST ptr,val
 */
ir_node *new_bd_sparc_Store(dbg_info *dbgi, ir_node *block, ir_node *ptr, ir_node *val, ir_node *mem, ir_mode *ls_mode, ir_entity *entity, int entity_sign, long offset, bool is_frame_entity);

extern ir_op *op_sparc_Branch;
ir_op *get_op_sparc_Branch(void);
int is_sparc_Branch(const ir_node *n);
/**
 * construct Branch node
 */
ir_node *new_bd_sparc_Branch(dbg_info *dbgi, ir_node *block, ir_node *op0, int proj_num);

extern ir_op *op_sparc_Mov;
ir_op *get_op_sparc_Mov(void);
int is_sparc_Mov(const ir_node *n);
/**
 * construct Mov node
 */
ir_node *new_bd_sparc_Mov_imm(dbg_info *dbgi, ir_node *block, int immediate_value);
/**
 * construct Mov node
 */
ir_node *new_bd_sparc_Mov_reg(dbg_info *dbgi, ir_node *block, ir_node *op0);

extern ir_op *op_sparc_Tst;
ir_op *get_op_sparc_Tst(void);
int is_sparc_Tst(const ir_node *n);
/**
 * construct Tst node
 */
ir_node *new_bd_sparc_Tst(dbg_info *dbgi, ir_node *block, ir_node *left, bool ins_permuted, bool is_unsigned);

extern ir_op *op_sparc_SwitchJmp;
ir_op *get_op_sparc_SwitchJmp(void);
int is_sparc_SwitchJmp(const ir_node *n);
/**
 * construct SwitchJmp node
 */
ir_node *new_bd_sparc_SwitchJmp(dbg_info *dbgi, ir_node *block, ir_node *op0, int n_projs, long def_proj_num);

extern ir_op *op_sparc_Cmp;
ir_op *get_op_sparc_Cmp(void);
int is_sparc_Cmp(const ir_node *n);
/**
 * construct Cmp node
 */
ir_node *new_bd_sparc_Cmp_imm(dbg_info *dbgi, ir_node *block, ir_node *left, int immediate_value, bool ins_permuted, bool is_unsigned);
/**
 * construct Cmp node
 */
ir_node *new_bd_sparc_Cmp_reg(dbg_info *dbgi, ir_node *block, ir_node *left, ir_node *right, bool ins_permuted, bool is_unsigned);

extern ir_op *op_sparc_SymConst;
ir_op *get_op_sparc_SymConst(void);
int is_sparc_SymConst(const ir_node *n);
/**
 * construct SymConst node
 */
ir_node *new_bd_sparc_SymConst(dbg_info *dbgi, ir_node *block, ir_entity *entity);

extern ir_op *op_sparc_Sub;
ir_op *get_op_sparc_Sub(void);
int is_sparc_Sub(const ir_node *n);
/**
 * construct Sub node
 */
ir_node *new_bd_sparc_Sub_imm(dbg_info *dbgi, ir_node *block, ir_node *left, int immediate_value);
/**
 * construct Sub node
 */
ir_node *new_bd_sparc_Sub_reg(dbg_info *dbgi, ir_node *block, ir_node *left, ir_node *right);

extern ir_op *op_sparc_Load;
ir_op *get_op_sparc_Load(void);
int is_sparc_Load(const ir_node *n);
/**
 * construct Load: Load(ptr, mem) = LD ptr -> reg
 */
ir_node *new_bd_sparc_Load(dbg_info *dbgi, ir_node *block, ir_node *ptr, ir_node *mem, ir_mode *ls_mode, ir_entity *entity, int entity_sign, long offset, bool is_frame_entity);

extern ir_op *op_sparc_AddSP;
ir_op *get_op_sparc_AddSP(void);
int is_sparc_AddSP(const ir_node *n);
/**
 * alloc stack space
 */
ir_node *new_bd_sparc_AddSP(dbg_info *dbgi, ir_node *block, ir_node *stack, ir_node *size, ir_node *mem);



enum pn_sparc_SubSP {
	pn_sparc_SubSP_stack = 0,
	pn_sparc_SubSP_M = 1,
};

enum n_sparc_SubSP {
	n_sparc_SubSP_stack = 0,
	n_sparc_SubSP_size = 1,
	n_sparc_SubSP_mem = 2,
};

enum n_sparc_FrameAddr {
	n_sparc_FrameAddr_base = 0,
};

enum pn_sparc_Store {
	pn_sparc_Store_mem = 0,
};

enum n_sparc_Store {
	n_sparc_Store_ptr = 0,
	n_sparc_Store_val = 1,
	n_sparc_Store_mem = 2,
};

enum n_sparc_Tst {
	n_sparc_Tst_left = 0,
};

enum pn_sparc_Load {
	pn_sparc_Load_res = 0,
	pn_sparc_Load_M = 1,
};

enum n_sparc_Load {
	n_sparc_Load_ptr = 0,
	n_sparc_Load_mem = 1,
};

enum pn_sparc_AddSP {
	pn_sparc_AddSP_stack = 0,
	pn_sparc_AddSP_addr = 1,
	pn_sparc_AddSP_M = 2,
};

enum n_sparc_AddSP {
	n_sparc_AddSP_stack = 0,
	n_sparc_AddSP_size = 1,
	n_sparc_AddSP_mem = 2,
};


#endif
