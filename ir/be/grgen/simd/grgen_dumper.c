/*****************************************************************************
 * Program:		grgen_dumper.c
 * Function:	Dumps parts of a firm graph (those which have to be extracted
 *				as search and replace patterns) as a grGen rule.
 * Depends on:	Needs the analysis info generated by the pattern creator
 * Author:		Andreas Schoesser
 * Date:		2006-12-07
 *****************************************************************************/


// ---------------------------- INCLUDES --------------------------------

#include <assert.h>
#include <stdio.h>
#include <obst.h>

#include "simd_presets.h"

#include "firm_types.h"
#include "pmap.h"
#include "tv.h"
#include "irgwalk.h"

#include "grgen_dumper__t.h"
#include "create_pattern_t.h"
#include "firm_node_ext.h"

// ----------------------------- GLOABALS --------------------------------

// Saves the current indent value and keeps spaces in a string
#define MAX_INDENT 100
static char indent[MAX_INDENT] = "";
static int  current_indent = 0;

// Saves the current node number to generate node names
static int node_counter;
static int edge_counter;




/************************************************************************
 * Initializes the grgen_dumper module and dumps the GrGen File header
 * Returns:		An environment to be passed to all functions of the GrGen
 *				dumper.
 * Parameters:	file:	filename of the file to dump to
 *				append:	1 if the previous file content should be
 *						maintained.
 ************************************************************************/

grgen_dumper_env_t *init_grgen_dumper(char *file, int append)
{
	grgen_dumper_env_t *grgen_dumper_env = malloc(sizeof(grgen_dumper_env_t));
	FILE *fp;

	if(append)
		fp = fopen(file, "at");
	else
	{
		fp = fopen(file, "wt");

		// *** Dump header
		fprintf(fp, "%susing Firm;\n\n", indent);
	}

	grgen_dumper_env -> output_file = fp;
	return(grgen_dumper_env);
}



/************************************************************************
 * Frees information used by the grgen_dumper and closes the output file
 ************************************************************************/

void deinit_grgen_dumper(grgen_dumper_env_t *grgen_dumper_env)
{
	fclose(grgen_dumper_env->output_file);
	free(grgen_dumper_env);
}




/************************************************************************
 * Starts dumping
 * Returns
 * 1 if the complex operation uses the memory edge
 * 0 if no memory edge is used.
 ************************************************************************/

int dump_irgraph_grgen(grgen_dumper_env_t *grgen_dumper_env, graph_ana_info_t *graph_ana_info)
{
	FILE *fp = grgen_dumper_env -> output_file;
	dump_info_t dump_info;
	int uses_memory = 0;
	char irg_name[255];

	get_rule_name(graph_ana_info, irg_name);

	// Do initialization
	dump_info.irg = graph_ana_info->irg;							// Basically copy the graph_ana_struct, ugly
	dump_info.destroyed_regs = graph_ana_info->destroyed_regs;		// Should have used a pointer to the
	dump_info.register_access = graph_ana_info->register_access;	// graph_ana_info struct here
	dump_info.memory_access = graph_ana_info->memory_access;
	dump_info.nodes_to_dump = graph_ana_info->nodes_to_dump;
	dump_info.argument_nodes = graph_ana_info->argument_nodes;
	dump_info.complex_operation_block = graph_ana_info->complex_operation_block;
	dump_info.node_to_match_block = graph_ana_info->node_to_match_block;
	dump_info.has_result = graph_ana_info->has_result;
	dump_info.priority = graph_ana_info->priority;
	dump_info.mode_edge_map = pmap_create();		// Create some additional pmaps to hold
	dump_info.edge_name_map = pmap_create();		// node and edge name information etc.
	dump_info.node_name_map = pmap_create();
	dump_info.mode_name_map = pmap_create();
	dump_info.dump_condition = pmap_create();		// pmaps "misused" as lists here...
	dump_info.retyped_nodes = pmap_create();
	dump_info.eval_statements = pmap_create();
	dump_info.dump_everything = graph_ana_info->dump_everything;

	// Node and egde count start at 0 for each pattern to be dumped.
	node_counter = 0;
	edge_counter = 0;
	obstack_init(&(dump_info.node_names));
	obstack_init(&(dump_info.mode_names));

	// Dump rule header
	set_indent(0);
	fprintf(fp, "\n\n%srule %s\n%s{\n", indent, irg_name, indent);
	set_indent(2);
	if(!dump_info.dump_everything)
		fprintf(fp, "%spattern\n%s{\n", indent, indent);
	else
	{
		fprintf(fp, "%spattern { }\n", indent);
		fprintf(fp, "%sreplace\n%s{\n", indent, indent);
	}
	set_indent(4);

	// *** Dump the left side of the rule
	uses_memory = dump_pattern(&dump_info, fp);

	// *** Dump the right side of the rule
	if(!dump_info.dump_everything)	// Hack: If a whole graph is dumped, the pattern part will raise errors since no complex operations etc. are there
	{
		dump_replacement(&dump_info, uses_memory, fp);

		// *** Dump the eval part of the rule
		fprintf(fp, "\n%seval {\n", indent);
		set_indent(6);
		dump_mandatory_evals(&dump_info, uses_memory, fp);
		dump_vproj_nr(&dump_info, fp);	// Dumps all vproj_nr attribute assignments
		set_indent(4);
		fprintf(fp, "%s} /* Eval */\n", indent);

		// *** Close the replacement part

		set_indent(2);
		fprintf(fp, "%s} /* Replacement */\n", indent);
	}

	// *** Dump footer
	set_indent(0);
	fprintf(fp, "%s}\n", indent);

	// Clean up
	pmap_destroy(dump_info.mode_edge_map);
	pmap_destroy(dump_info.edge_name_map);
	pmap_destroy(dump_info.node_name_map);
	pmap_destroy(dump_info.mode_name_map);
	pmap_destroy(dump_info.dump_condition);
	pmap_destroy(dump_info.retyped_nodes);
	pmap_destroy(dump_info.eval_statements);
	obstack_free(&(dump_info.node_names), NULL);
	obstack_finish(&(dump_info.node_names));
	obstack_free(&(dump_info.mode_names), NULL);
	obstack_finish(&(dump_info.mode_names));

	return(uses_memory);
}


/************************************************************************
 * Dumps the left hand side of the rule
 ************************************************************************/

static int dump_pattern(dump_info_t *dump_info, FILE *fp)
{
	struct pmap *nodes_to_dump = dump_info->nodes_to_dump;
	pmap_entry *entry;
	int uses_memory = 0;

	// Dump all nodes
	pmap_foreach(nodes_to_dump, entry)
	{
		ir_node *n = (ir_node *) entry->key;
		ir_opcode code;

		// Dump node
		if(get_irn_opcode(n) == iro_Proj && get_irn_modecode(n) == irm_M)
			uses_memory = 1;
		dump_grgen_node(n, dump_info, fp);
		dump_grgen_mode(n, dump_info, fp, NULL);
		//dump_grgen_block(n, dump_info, fp);


		// If a condition has to be dumped afterwards: Save the node for later
		code = get_irn_opcode(n);
		if(code == iro_MultipleAdd ||
		   code == iro_VProj ||
		   code == iro_Const ||
		   code == iro_Proj ||
		   code == iro_Phi)
			pmap_insert(dump_info -> dump_condition, n, NULL);
	}

	// Dump all edges
	pmap_foreach(nodes_to_dump, entry)
	{
		ir_node *n = (ir_node *) entry->key;
		int i;

		// Dump edges
		for(i = -1; i < get_irn_arity(n); i++)
			dump_grgen_edge(n, i, dump_info, fp);
	}

	// Dump the edge from a special pattern node to it's block. This block will later be the block
	// of the complex operation
	//dump_complex_operation_block_match(dump_info, fp);

	if(!dump_info->dump_everything)
	{

		fprintf(fp, "\n%sif\n%s{\n", indent, indent);
		set_indent(6);

		pmap_foreach(dump_info->dump_condition, entry)
		{
			ir_node *n = (ir_node *) entry->key;
			dump_grgen_condition(n, dump_info, fp);
		}
		set_indent(4);
		fprintf(fp, "%s} /* Conditions */\n", indent);
	}

	set_indent(2);
	fprintf(fp, "%s} /* Pattern */\n", indent);
	return(uses_memory);
}



/************************************************************************
 * Dumps the right hand side of the rule
 ************************************************************************/

static void dump_replacement(dump_info_t *dump_info, int uses_memory, FILE *fp)
{
	pmap_entry *entry;
	register_access_descr_t *register_access_descr;
	memory_access_descr_t *memory_access_descr;

	// dump grGen "replace" statement
	fprintf(fp, "\n%smodify {\n", indent);
	set_indent(4);

	// Dump the complex operation node with it's projs and vprojs
	dump_complex_operation(dump_info, fp, uses_memory);

	// Dump the rest of the replacement nodes. Do retyping to VProj if necessary
	fprintf(fp, "\n");

	// First dump all nodes.
	pmap_foreach(dump_info->nodes_to_dump, entry)
	{
		ir_node *n = (ir_node *) entry->key;

		if((register_access_descr = pmap_get(dump_info->register_access, n)) != NULL)
		{
			// Nodes that represent a result in a register have to be retyped
			if(register_access_descr -> load_store == REGISTER_STORE)
			{
				// Find out, if this store is a component of a vector or a standalone scalar
				argument_descr_t *arg_descr;

				arg_descr = pmap_get(dump_info->argument_nodes, register_access_descr->pointer_base);
				assert(arg_descr && "No argument information available! Should have been created during analysis!");

				// Treat SCALAR and VECTOR_COMPONENT differently
				// A vector component has to be retyped to VProj
				// A scalar has to be retyped to a Proj
				switch(arg_descr->argument_type)
				{
					case ARGUMENT_VECTOR:
							// Not needed:
							// assert(get_irn_opcode(n) != iro_VProj); // An existing VProj would be a register LOAD

							// Node is a vector result to be stored in a register:
							// Retype the node to VProj
							// Connect it with the Data Proj of the complex operation
							dump_retyping_to_vproj(n, NULL, dump_info, VECTOR_OP_PROJDATA_NAME, fp);
							//dump_grgen_block(n, dump_info, fp);
							break;

					case ARGUMENT_SCALAR:
							// Retype the scalar result to proj
							// Connect it directly with the operation
							dump_retyping_to_proj(n, NULL, dump_info, VECTOR_OP_NAME, fp);
							//dump_grgen_block(n, dump_info, fp);
							//assert(0 && "// TODO: retype_to_proj, if the result is a scalar");
							break;

					default:
							assert(0 && "Argument Type not implemented!");
				}

				continue;
			}
		}

		if((memory_access_descr = pmap_get(dump_info->memory_access, n)) != NULL)
		{
			if(memory_access_descr->load_store == MEMORY_STORE)
			{
					// Node is part of a memory store, that is STORE or PROJM node.
					// Retype it to id.
					// Trick to keep the M-edge predecessor of the Store node as
					// the predecessor of the Id Node without actually matching the predecessor:
					// Since we don't dump the M-Edge of the STORE but the Adr and Value edges and
					// we can just "not dump" the 2 matched edges. The Adr and Value edges are therefore
					// killed by the graph rewriting system. The M-Edge is not specified at all and the
					// GRS is supposed to leave the edge as it was. M-Edges of Stores are at position 0,
					// so the kept edge is also at position 0, which is correct.
					dump_grgen_retyped_node(n, op_Sync, dump_info, fp);
					dump_grgen_delete_incoming_edges(n, dump_info, fp); // Only the M edge (not matched) will persist
					change_mode(n, mode_M, dump_info, fp);
					continue;
			}
		}

		// Same for the STORE PROJ M
		if(get_irn_opcode(n) == iro_Proj && (memory_access_descr = pmap_get(dump_info->memory_access, get_irn_n(n, 0))) != NULL)
		{
			if(memory_access_descr->load_store == MEMORY_STORE)
			{
				dump_grgen_retyped_node(n, op_Sync, dump_info, fp);
				change_mode(n, mode_M, dump_info, fp);
				continue;
			}
		}
	}


	// Now dump the edges of the replaced nodes, that could not be dumped before:
	// - Eliminated STOREs and ProjMs
	pmap_foreach(dump_info->retyped_nodes, entry)
	{
		const ir_node *n = entry->key;
		if(pmap_contains(dump_info->memory_access, n))
		{
			memory_access_descr_t *memory_access_descr = pmap_get(dump_info->memory_access, n);
			assert(memory_access_descr->load_store == MEMORY_STORE);

			if(get_irn_opcode(n) == iro_Proj)
			{
				// dump in edge of the retyped ProjM
				fprintf(fp, "%s%s -:df-> %s;\n", indent, pmap_get(dump_info->node_name_map, n), pmap_get(dump_info->node_name_map, get_irn_n(n, 0)));
			}
		}
	}
	//dump_complex_operation_block_match(dump_info, fp);

	/* Don't close the replacement since evals have moved into the replacement part  */
#if 0
	set_indent(2);
	fprintf(fp, "%s} /* Replacement */\n", indent);
#endif
}



/************************************************************************
 * Dumps the new complex operation node and it's Projs and Vprojs
 ************************************************************************/

void dump_complex_operation(dump_info_t *dump_info, FILE *fp, int uses_memory)
{
	pmap_entry *entry;
	int i, mem_slot = (uses_memory) ? 1 : 0, max_argument;
	char *mode_node_name, eval[100];

	// Generate Vector operation
	fprintf(fp, "%s%s : Complex;\n", indent, VECTOR_OP_NAME);

	// Dump the mode of the Complex op (mode T).
	mode_node_name = dump_grgen_mode_node(mode_T, dump_info, fp);
	fprintf(fp, "%s%s -:has_mode-> %s;\n", indent, VECTOR_OP_NAME, mode_node_name);

	// Connect the complex operation to it's block
	assert(pmap_contains(dump_info->node_name_map, dump_info->complex_operation_block) && "Complex operation's block predecessor must have already been dumped in the positive pattern!");
	fprintf(fp, "%s%s -pos0_%d:df-> %s;\n", indent, VECTOR_OP_NAME, edge_counter++, pmap_get(dump_info->node_name_map, dump_info->complex_operation_block));

	if(dump_info->has_result)
	{
		// Dump the res proj node projecting the complete vector out of the complex operation
		fprintf(fp, "%s%s : Proj;\n", indent, VECTOR_OP_PROJDATA_NAME);
		mode_node_name = dump_grgen_mode_node(mode_LLu, dump_info, fp);
		fprintf(fp, "%s%s -:has_mode-> %s;\n", indent, VECTOR_OP_PROJDATA_NAME, mode_node_name);
		fprintf(fp, "%s%s -pos0_%d:df-> %s;\n", indent, VECTOR_OP_PROJDATA_NAME, edge_counter++,  pmap_get(dump_info->node_name_map, dump_info->complex_operation_block));
		fprintf(fp, "%s%s -pos1_%d:df-> %s;\n", indent, VECTOR_OP_PROJDATA_NAME, edge_counter++, VECTOR_OP_NAME);
		sprintf(eval, "%s.proj = %d;", VECTOR_OP_PROJDATA_NAME, 0);
		add_eval(dump_info, eval);
	}


	// Connect the complex operation to it's arguments
	// Caution: The argument-nodes must have not been retyped!
	i = 0;
	max_argument = -1000;
	pmap_foreach(dump_info->argument_nodes, entry)
	{
		ir_node *n = (ir_node *) entry->key;
		ir_node *argument;
		argument_descr_t *argument_descr = entry -> value;
		int arg_nr = argument_descr->arg_nr;

		if(arg_nr < 0)
			continue;
		assert(pmap_contains(dump_info->node_name_map, n) && "The pointer base node must have already been dumped in the positive pattern!");

		if(argument_descr->argument_location == ARGUMENT_SIMD_REGISTER)
			argument = n;
		else
			argument = argument_descr->vec_op_input;

		fprintf(fp, "%s%s -pos%d_%d:df-> %s;\n", indent, VECTOR_OP_NAME, arg_nr + 1, edge_counter++, pmap_get(dump_info->node_name_map, argument));
		if(max_argument < arg_nr)
			max_argument = arg_nr;
	}

	// Do preparations to connect the memory edge to the complex operation
	if(uses_memory)
	{
		// Dump a dummy in-edge used to connect the memory in manually later
		fprintf(fp, "%s%s -pos%d_%d:df-> Bad%d : Bad;\n", indent, VECTOR_OP_NAME, max_argument + 2, edge_counter++, node_counter);

		// Generate ProjM node to connect the rest of the replace pattern with
		fprintf(fp, "%s%s : Proj;\n", indent, VECTOR_OP_PROJM_NAME);
		fprintf(fp, "%s%s -:has_mode-> mode_M_node;\n", indent, VECTOR_OP_PROJM_NAME);
		fprintf(fp, "%s%s -pos1_%d:df-> %s;\n", indent, VECTOR_OP_PROJM_NAME, edge_counter++, VECTOR_OP_NAME);
		fprintf(fp, "%s%s -pos0_%d:df-> %s;\n", indent, VECTOR_OP_PROJM_NAME, edge_counter++, pmap_get(dump_info->node_name_map, dump_info->complex_operation_block));

		// Add eval to set the proj nr
		sprintf(eval, "%s.proj = %d;", VECTOR_OP_PROJM_NAME, (dump_info->has_result) ? 1 : 0);
		add_eval(dump_info, eval);
	}

	i = 0;
	pmap_foreach(dump_info->destroyed_regs, entry)
	{
		//ir_node *end_node = get_irg_end(dump_info->irg);
		//char *end_name = pmap_get(dump_info->node_name_map, end_node);
		char proj_name[255], keep_name[255];

//		assert(end_name && "End node has to be already dumped in positive pattern!");

		sprintf(proj_name, "Proj%d", node_counter++);
		sprintf(keep_name, "IR_Keep%d", i);
		fprintf(fp, "%s%s : Proj;\n", indent, proj_name);
		fprintf(fp, "%s%s -:has_mode-> mode_LLu_node;\n", indent, proj_name);
		fprintf(fp, "%s%s -pos0_%d:df-> %s;\n", indent, proj_name, edge_counter++, pmap_get(dump_info->node_name_map, dump_info->complex_operation_block));
		fprintf(fp, "%s%s -pos1_%d:df-> %s;\n", indent, proj_name, edge_counter++, VECTOR_OP_NAME);
		fprintf(fp, "%s%s : IR_Keep;\n", indent, keep_name);
		fprintf(fp, "%s%s -pos%d_%d:df-> %s;\n", indent, keep_name, i + 1, edge_counter++, proj_name);
		fprintf(fp, "%s%s -pos0_%d:df-> %s;\n", indent, keep_name, edge_counter++, pmap_get(dump_info->node_name_map, dump_info->complex_operation_block));
		//fprintf(fp, "%s%s -:df-> %s;\n", indent, end_name, keep_name);
		sprintf(eval, "%s.proj = %d;", proj_name, (dump_info->has_result + uses_memory + i));
		add_eval(dump_info, eval);
		i++;
	}
}



/************************************************************************
 * Dumps a node in GrGen Format
 ************************************************************************/

static void dump_grgen_node(ir_node *n, dump_info_t *dump_info, FILE *fp)
{
	char *node_name;

	// Already dumped the node? Then do nothing
	if(pmap_contains(dump_info -> node_name_map, n))
		return;

	// Else generate new node name and dump the node

	node_name = obstack_alloc(&(dump_info -> node_names), MAX_NODENAME_LEN);

	if(!pmap_contains(dump_info->argument_nodes, n))
	{
		register_access_descr_t *register_access_descr = pmap_get(dump_info->register_access, n);

		if(n == dump_info->complex_operation_block)
			sprintf(node_name, "%s", COMPLEX_OPERATION_BLOCK_NAME);
		else if(register_access_descr != NULL && register_access_descr -> load_store == REGISTER_STORE) // Register STORE nodes get a special name to be fao
			sprintf(node_name, "%s%d_%s%d", VECTOR_RESULT_NAME, register_access_descr->array_index, get_op_name(get_irn_op(n)), get_irn_node_nr(n));
		else
			sprintf(node_name, "%s%d", get_op_name(get_irn_op(n)), get_irn_node_nr(n));

		if(get_irn_opcode(n) == iro_Bad)  // A bad node that comes out of specification is a generic IR_node
			fprintf(fp, "%s%s : %s;\n", indent, node_name, "IR_node");
		else
			fprintf(fp, "%s%s : %s;\n", indent, node_name, get_op_name(get_irn_op(n)));
	}
	else
	{
		// Argument nodes get a special name, so that they can be found after
		// matching to test if their position is legal
		argument_descr_t *arg_descr = pmap_get(dump_info->argument_nodes, n);
		if(arg_descr->arg_nr != -1)
			sprintf(node_name, "Arg_%d", arg_descr->arg_nr);
		else
			sprintf(node_name, "Result");  /// ???? What did I do here?
		fprintf(fp, "%s%s : %s;\n", indent, node_name, VECTOR_BASE_TYPE);

	}

	pmap_insert(dump_info -> node_name_map, n, node_name);
	node_counter++;
}



/************************************************************************
 * Dump grGen code for retyping a node to a new opCode.
 * The mode stays the same.
 * Changes also the already saved node_name in node_name_map
 * Returns the node name generated for the retyped node.
 ************************************************************************/

static char *dump_grgen_retyped_node(ir_node *n, ir_op *new_op, dump_info_t *dump_info, FILE *fp)
{
	char *node_name;

	// A retyped node should have already been dumped.
	assert(pmap_contains(dump_info->node_name_map, n));

	// Else generate new node name and dump the retyped node
	node_name = obstack_alloc(&(dump_info -> node_names), MAX_NODENAME_LEN);
	sprintf(node_name, "%s%d", get_op_name(new_op), node_counter);
	fprintf(fp, "%s%s : %s<%s>;\n", indent, node_name, get_op_name(new_op), pmap_get(dump_info->node_name_map, n));
	pmap_insert(dump_info -> node_name_map, n, node_name);

	// Save the retyped op
	pmap_insert(dump_info -> retyped_nodes, n, (void *) new_op);
	node_counter++;

	// Dump the block of the original node had one.
	// dump_grgen_edge(n, -1, dump_info, fp);

	return(node_name);
}



/*************************************************************************
 * Dumps 'delete' statements for all incoming egdes that have been matched
 * except for the bock edge and the mode edge
 * This is useful for nodes that were retyped to VProj or Sync and
 * needing new incoming edges now;
 *************************************************************************/

void dump_grgen_delete_incoming_edges(ir_node *n, dump_info_t *dump_info, FILE *fp)
{
	char **nodes_edge_names;
	int  i, deleted = 0;

	// Delete all incoming edges of the original node since a retyped node
	// will get new in edges (except the block edge and mode egde)

	if(get_irn_arity(n) > 0)
	{
		fprintf(fp, "%sdelete(", indent);
		nodes_edge_names = pmap_get(dump_info->edge_name_map, n);
		assert(nodes_edge_names != NULL);

		for(i = get_irn_arity(n); i > 0; i--)
			if(nodes_edge_names[i] != NULL)
			{
				fprintf(fp, "%c%s", (deleted == 0) ? ' ' : ',', nodes_edge_names[i]);
				deleted = 1;
			}

			fprintf(fp, ");\n");
	}
}



/************************************************************************
 * Dumps
 * - The Block node of a ir_node if it has not been dumped before
 * - The edge to the block node if n is not an argument or Const
 ************************************************************************/

static void dump_grgen_block(ir_node *n, dump_info_t *dump_info, FILE *fp)
{
	ir_node *block;
	return;

	if(get_irn_opcode(n) == iro_Block)  // A block has no block predecessor
		return;

	if(get_irn_opcode(n) == iro_Const || pmap_contains(dump_info->argument_nodes, n))
		return;

	if(get_irn_opcode(n) == iro_VProj)
		return;

	block = get_nodes_block(n);
	// Dump the block node if necessary
	if(!pmap_contains(dump_info->node_name_map, block))
	{
		dump_grgen_node(block, dump_info, fp);
		dump_grgen_mode(block, dump_info, fp, NULL);
	}

	// Dump the edge to the block node
	dump_grgen_edge(n, -1, dump_info, fp);
}



/************************************************************************
 * Dumps an edge in GrGen format
 ************************************************************************/

static void dump_grgen_edge(ir_node *n, int n_edge, dump_info_t *dump_info, FILE *fp)
{
	ir_node *to_node;
	char *from_node_name, *to_node_name;
	char **nodes_edge_names;

	// Don't dump a block edge if n is a block or n is a const or n is an argument for the complex
	// operation which can be in a random block in the host graph
	if(!dump_info->dump_everything)
		if(n_edge == -1 && n != dump_info->node_to_match_block && (is_Block(n) || (get_irn_opcode(n) == iro_VProj && dump_info->priority != PRIORITY_CLEANUP /* HACK!!! */ ) ||
			 get_irn_opcode(n) == iro_Const || get_irn_opcode(n) == iro_Cmp ||
			(get_irn_opcode(n) == iro_Proj && get_irn_modecode(n) != irm_M) ||
			get_irn_opcode(n) == iro_MultipleAdd ||
			get_irn_opcode(n) == iro_Load ||
			get_irn_opcode(n) == iro_Proj ||
			get_irn_opcode(n) == iro_Conv ||
			get_irn_op(n) == op_IrNode ||
			pmap_contains(dump_info->argument_nodes, n)))
				return;


	// Check if to_node has also to be dumped. If not, skip this edge
	// We have to dump to_node here, because to_node has to be known by grgen before
	// connecting an edge to it.
	to_node =  get_irn_n(n, n_edge);
	if(!pmap_contains(dump_info -> nodes_to_dump, to_node))
		return;

	if((nodes_edge_names = pmap_get(dump_info -> edge_name_map, n)) == NULL)
	{
		nodes_edge_names = (char **) obstack_alloc(&(dump_info->node_names), (get_irn_arity(n) + 1) * sizeof(char *));
		memset(nodes_edge_names, 0, (get_irn_arity(n) + 1) * sizeof(char *));
		pmap_insert(dump_info->edge_name_map, n, nodes_edge_names);
	}


	// Is the target node a node with memory mode?
	if(dump_info->dump_everything || get_mode_modecode(get_irn_mode(to_node)) != irm_M)
	{
		// No, we can dump the edge since it's no memory edge:

		// Dumps node only when it was not dumped before
		// dump_grgen_node(to_node, node_name_map, node_names, mode_name_map, mode_names, fp);
		// dump_grgen_node(to_node, dump_info, fp);

		assert(pmap_contains(dump_info -> node_name_map, n));
		assert(pmap_contains(dump_info -> node_name_map, to_node));
		from_node_name = (char *) pmap_get(dump_info -> node_name_map, n);
		to_node_name = (char *) pmap_get(dump_info -> node_name_map, to_node);

		// Don't dump edge number for certain nodes that are commutative (like ADD operation)
		if(!dump_info->dump_everything && (n_edge != -1 && (get_irn_opcode(n) == iro_Add ||
		   get_irn_opcode(n) == iro_MultipleAdd ||
		   get_irn_opcode(n) == iro_Mul) ||
		   get_irn_opcode(n) == iro_Block ||
		   get_irn_opcode(n) == iro_Phi))
		{
				char edge_name[50], *edge_name_obst;

				sprintf(edge_name, "e%d", edge_counter++);
				edge_name_obst = obstack_alloc(&(dump_info->node_names), strlen(edge_name) + 1);
				strcpy(edge_name_obst, edge_name);
				nodes_edge_names[n_edge + 1] = edge_name_obst;

				fprintf(fp, "%s%s -%s:df-> %s;\n", indent, from_node_name, edge_name_obst, to_node_name);
		}
		else
		{
				char edge_name[50], *edge_name_obst;

				sprintf(edge_name, "pos%d_%d", n_edge + 1, edge_counter++);
				edge_name_obst = obstack_alloc(&(dump_info->node_names), strlen(edge_name) + 1);
				strcpy(edge_name_obst, edge_name);
				nodes_edge_names[n_edge + 1] = edge_name_obst;

				fprintf(fp, "%s%s -%s:df-> %s;\n", indent, from_node_name, edge_name_obst, to_node_name);
		}
		/*
		switch(get_irn_opcode(n))
		{
			case iro_Add:
			case iro_MultipleAdd:
			case iro_Mul:

				break;
			default:
				fprintf(fp, "%s%s -pos%d_%d:df-> %s;\n", indent, from_node_name, n_edge + 1, edge_counter++, to_node_name);
				break;
		}*/

	}
}



/************************************************************************
 * Dumps an FIRM Mode as GrGen Code
 * If source_node_name == NULL, that name of n that was already
 * generated is used.
 * If source_node_name != NULL, this given source will be used
 * (useful for retyped nodes)
 ************************************************************************/

static void dump_grgen_mode(ir_node *n, dump_info_t *dump_info, FILE *fp, ir_mode *alt_mode)
{
	char *node_name = (char *) pmap_get(dump_info -> node_name_map, n);
	ir_mode *irn_mode = (alt_mode != NULL) ? alt_mode : get_irn_mode(n);
	char edge_name[50];
	char *mode_node_name;

	if(pmap_contains(dump_info->argument_nodes, n))
		irn_mode = mode_ANY;
	mode_node_name = dump_grgen_mode_node(irn_mode, dump_info, fp);

	//mode_code =  get_mode_modecode(irn_mode);
	//mode_name =  get_mode_name(irn_mode);



#if 0
	// Check if the mode node has already been created
	if(!pmap_contains(dump_info -> mode_name_map, (void *) mode_code))
	{
		// No, create a new mode-node
		mode_node_name = obstack_alloc(&(dump_info -> mode_names), MAX_NODENAME_LEN);
		sprintf(mode_node_name, "mode_%s_node", mode_name);
		pmap_insert(dump_info -> mode_name_map, (int *) mode_code, mode_node_name);
		// Dump the edge from the current node to it's mode node
		fprintf(fp, "%s%s -:has_mode-> %s : Mode_%s;\n", indent, node_name, mode_node_name, mode_name);
	}
	else
	{
#endif
		// Yes, use the given mode-node
		//mode_node_name = pmap_get(dump_info -> mode_name_map, (void *) mode_code);
		sprintf(edge_name, "m%d", edge_counter++);


		if(pmap_get(dump_info->mode_edge_map, n) == NULL)
		{
			char *edge_name_obst = obstack_alloc(&(dump_info->node_names), strlen(edge_name) + 1);
			strcpy(edge_name_obst, edge_name);
			pmap_insert(dump_info->mode_edge_map, n, edge_name_obst);
		}

	    // Dump the edge from the current node to it's mode node
		fprintf(fp, "%s%s -%s:has_mode-> %s;\n", indent, node_name, edge_name, mode_node_name);
#if 0
	}
#endif
}



/************************************************************************
 * Dumps a node representing a node
 ************************************************************************/

char *dump_grgen_mode_node(ir_mode *irn_mode, dump_info_t *dump_info, FILE *fp)
{
	modecode mode_code = get_mode_modecode(irn_mode);
	const char *mode_name =  get_mode_name(irn_mode);
	char *mode_node_name;

	if(!pmap_contains(dump_info -> mode_name_map, (void *) mode_code))
	{
		// No, create a new mode-node
		mode_node_name = obstack_alloc(&(dump_info -> mode_names), MAX_NODENAME_LEN);
		sprintf(mode_node_name, "mode_%s_node", mode_name);
		pmap_insert(dump_info -> mode_name_map, (void *) mode_code, mode_node_name);
		fprintf(fp, "%s%s : Mode_%s;\n", indent, mode_node_name, mode_name);
		return(mode_node_name);
	}
	else
	{
		return((char *) pmap_get(dump_info -> mode_name_map, (void *) mode_code));
	}

}



/************************************************************************
 * Dumps the condition for the given node, depending on the node's
 * attributes and the node's opcode
 ************************************************************************/

static void dump_grgen_condition(ir_node *n, dump_info_t *dump_info, FILE *fp)
{
	char *node_name;
	ir_opcode code = get_irn_opcode(n);

	if(code == iro_MultipleAdd)
	{
		node_name = pmap_get(dump_info->node_name_map, n);
		fprintf(fp, "%s%s.arity == %d;\n", indent, node_name, get_irn_arity(n));
		return;
	}

	if(code == iro_Const)
	{
		node_name = pmap_get(dump_info->node_name_map, n);
		fprintf(fp, "%s%s.value == \"%d\";\n", indent, node_name, get_tarval_long(get_Const_tarval(n)));
		return;
	}

	if(code == iro_VProj)
	{
		node_name = pmap_get(dump_info->node_name_map, n);
		fprintf(fp, "%s%s.proj == %d;\n", indent, node_name, get_VProj_proj(n));
		return;
	}

	if(code == iro_Proj)
	{
		if(!pmap_contains(dump_info->argument_nodes, n))
		{
			node_name = pmap_get(dump_info->node_name_map, n);
			fprintf(fp, "%s%s.proj == %d;\n", indent, node_name, get_Proj_proj(n));
		}
		return;
	}


	if(code == iro_Phi)
	{
		ir_node *phi_block = get_nodes_block(n);
		char **edge_names_phi, **edge_names_block;
		int i;

		assert((get_irn_arity(n) == get_irn_arity(phi_block)) && "Phi has other arity than it's block! Pattern seems to be broken.");

		// Load the edge names that have been saved
		edge_names_phi = pmap_get(dump_info->edge_name_map, n);
		edge_names_block = pmap_get(dump_info->edge_name_map, phi_block);
		assert(edge_names_phi && edge_names_block && "Some edge names have not been dumped!");

		// Correlate the matched phi edges with the matched block edges
		// Caution: Position 0 in the edge_names array is the block edge, so start at 1
		for(i = 1; i < get_irn_arity(n) + 1; i++)
		{
				assert(edge_names_phi[i] != NULL && edge_names_block[i] != NULL && "Some edges have not been dumped!");

				fprintf(fp, "%s%s.pos == %s.pos;\n", indent, edge_names_phi[i], edge_names_block[i]);
		}
		return;
	}

	assert(0 && "Nodes attributes not supported");
}




/************************************************************************
 * Dump grGen code for retyping a special node
 ************************************************************************/

static void dump_retyping_to_vproj(ir_node *n, ir_node *complex_operation, dump_info_t *dump_info, char *vector_op_node_name, FILE *fp)
{
	// Dump the grGen code for retyping
	register_access_descr_t *register_access_descr;
	char *node_name;

	/*char *node_name = obstack_alloc(&(dump_info->node_names), MAX_NODENAME_LEN);

	// A node that should be retyped must be already there in the pattern part.
	assert(pmap_contains(dump_info->node_name_map, n));
	// Generate a node name for that VProj
	sprintf(node_name, "VProj%d", node_counter);
	fprintf(fp, "%s%s : VProj<%s>;\n", indent, node_name, pmap_get(dump_info->node_name_map, n));
	dump_grgen_mode(n, dump_info, fp, node_name); */

	node_name = dump_grgen_retyped_node(n, op_VProj, dump_info, fp);
	dump_grgen_delete_incoming_edges(n, dump_info, fp);

	// Dump the edge to the complex operation
	fprintf(fp, "%s%s -pos1_%d:df-> %s;\n", indent, node_name, edge_counter++, vector_op_node_name);
	node_counter++;

	// Save generated VProj Node name for later usage
	register_access_descr = pmap_get(dump_info->register_access, n);
	register_access_descr->replace_node_name = node_name;
}



/************************************************************************
 * Dump grGen code for retyping a special node
 ************************************************************************/

static void dump_retyping_to_proj(ir_node *n, ir_node *complex_operation, dump_info_t *dump_info, char *vector_op_node_name, FILE *fp)
{
	// Dump the grGen code for retyping
	register_access_descr_t *register_access_descr;
	char *node_name;


	node_name = dump_grgen_retyped_node(n, op_Proj, dump_info, fp);
	dump_grgen_delete_incoming_edges(n, dump_info, fp); // Will get a new edge to the complex op
	dump_grgen_mode(n, dump_info, fp, NULL);

	// Dump the edge to the complex operation
	fprintf(fp, "%s%s -pos1_%d:df-> %s;\n", indent, node_name, edge_counter++, vector_op_node_name);
	node_counter++;

	// Save generated VProj Node name for later usage
	register_access_descr = pmap_get(dump_info->register_access, n);
	register_access_descr->replace_node_name = node_name;
}



/************************************************************************
 * Dump grGen Code to add the VProj Nr to VProj nodes after replacement
 ************************************************************************/

static void dump_vproj_nr(dump_info_t *dump_info, FILE *fp)
{
	pmap_entry *entry;

	pmap_foreach(dump_info -> register_access, entry)
	{
		ir_node *n = (ir_node *) entry->key;
		register_access_descr_t *register_access_descr = entry->value;

		// Only VProjs that represent a store have to be changed
		if(register_access_descr->load_store == REGISTER_STORE)
			fprintf(fp, "%s%s.proj = %d;\n", indent, pmap_get(dump_info->node_name_map, n) /*register_access_descr->replace_node_name*/, register_access_descr->array_index);
	}
}


/************************************************************************
 * Sets current indent
 ************************************************************************/

void set_indent(int i)
{
	int j;

	// Generate a string containing i blank characters
	if(i < MAX_INDENT - 1)
	{
		for(j = 0; j < i; j++)
			indent[j] = ' ';
		indent[j] = 0x0;
		current_indent = i;
	}
}



/************************************************************************
 * Gets current indent value
 ************************************************************************/

int  get_indent(void)
{
	return(current_indent);
}

void dump_complex_operation_block_match(dump_info_t *dump_info, FILE *fp)
{
	fprintf(fp, "%s%s -:df-> %s;\n", indent, pmap_get(dump_info->node_name_map, dump_info->node_to_match_block), pmap_get(dump_info->node_name_map, dump_info->complex_operation_block));
}


/************************************************************************
 * Dumps some evals which are mandatory
 ************************************************************************/

void dump_mandatory_evals(dump_info_t *dump_info, int uses_memory, FILE *fp)
{
	pmap_entry *entry;

	pmap_foreach(dump_info->eval_statements, entry)
	{
		char *statement = (char *) entry->key;
		fprintf(fp, "%s%s\n", indent, statement);
	}
}


/************************************************************************
 * Adds an eval to the list that has to be dumped at the end
 ************************************************************************/

void add_eval(dump_info_t *dump_info, char *eval)
{
	char *eval_obst = obstack_alloc(&(dump_info->node_names), strlen(eval) + 5);

	strcpy(eval_obst, eval);
	pmap_insert(dump_info->eval_statements, eval_obst, NULL);
}



/*************************************************************************
 * Changes the mode of an already dumped node. Deletes the old mode edge
 * and inserts a new one. To be used e.g. in the replacement graph.
 *************************************************************************/

void change_mode(ir_node *n, ir_mode *m, dump_info_t *dump_info, FILE *fp)
{
	char *mode_edge_name = pmap_get(dump_info->mode_edge_map, n);

	if(mode_edge_name != NULL)
	{
		fprintf(fp, "%sdelete(%s);\n", indent, mode_edge_name);
		pmap_insert(dump_info->mode_edge_map, n, NULL);
		dump_grgen_mode(n, dump_info, fp, m);
	}
}


/************************************************************************
 * Sets up "fake" graph analysis information to just dump all nodes of
 * an ir graph. Used for the AGTIVE workshop.
 * Parameters:	irg:	The irg to dump
 *
 *
 ************************************************************************/

void dump_irgraph_complete_grgen(ir_graph *irg, char *filename, int append)
{
	graph_ana_info_t graph_ana_info;
	struct obstack obst;
	grgen_dumper_env_t *gd_env;

	obstack_init(&obst);

	graph_ana_info.irg = irg;
	graph_ana_info.nodes_to_dump = pmap_create();
	graph_ana_info.register_access = pmap_create(); // Those pmaps are not filled here, but needed by the dumper
	graph_ana_info.memory_access = pmap_create();
	graph_ana_info.argument_nodes = pmap_create();
	graph_ana_info.destroyed_regs = pmap_create();
	graph_ana_info.obst = &obst;
	graph_ana_info.num_simd_arguments = 0;
	graph_ana_info.complex_operation_block = NULL;
	graph_ana_info.node_to_match_block = NULL;
	graph_ana_info.emit_statement = NULL;
	graph_ana_info.has_result = 0;
	graph_ana_info.variant_nr = 0;
	graph_ana_info.priority = 0;
	graph_ana_info.dump_everything = 1;

	gd_env = init_grgen_dumper(filename, append);
	irg_walk_graph(graph_ana_info.irg, collect_nodes, NULL, &graph_ana_info);
	dump_irgraph_grgen(gd_env, &graph_ana_info);
	deinit_grgen_dumper(gd_env);

	pmap_destroy(graph_ana_info.nodes_to_dump);
	pmap_destroy(graph_ana_info.destroyed_regs);
	pmap_destroy(graph_ana_info.register_access);
	pmap_destroy(graph_ana_info.memory_access);
	pmap_destroy(graph_ana_info.argument_nodes);
	obstack_free(&obst, NULL);
	obstack_finish(&obst);
}



/************************************************************************
 * Collects all nodes of a ir graph, so that the ir graph can be
 * dumped completely
 ************************************************************************/


static void collect_nodes(ir_node *n, void * env)
{
	graph_ana_info_t *graph_ana_info = (graph_ana_info_t *) env;

	pmap_insert(graph_ana_info->nodes_to_dump, n, NULL);
}
