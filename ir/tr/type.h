/* Copyright (C) 1998 - 2000 by Universitaet Karlsruhe
** All rights reserved.
**
** Authors: Martin Trapp, Christian Schaefer &
**          Goetz Lindenmaier
**
** type.h: datastructures to hold type information.
*/

# ifndef _TYPE_H_
# define _TYPE_H_

# include "common.h"
# include "ident.h"
# include "irmode.h"

/* for recursive type definiton */
typedef union type type;

/* visited flag to traverse the type information */
extern unsigned long type_visited;

/*******************************************************************/
/** TYPE_CLASS                                                    **/
/*******************************************************************/

typedef struct {
  firm_kind kind;
  ident *name;
  /** needs list with it's entities -- does it really??
      Entities can be added during their creation.
  int n_members;
  entity **member; **/
  unsigned long visit;     /* visited counter for walks of the type information */
} type_class;


/* create a new type_class */
type_class *new_type_class (ident *name);

/* manipulate fields of type_class */
char  *get_class_name  (type_class *clss);
ident *get_class_ident (type_class *clss);
/*
void   set_class_name  (type_class *clss, char *name);
void   set_class_ident (type_class *clss, ident* ident);
*/

/*******************************************************************/
/** TYPE_STRCT                                                   **/
/*******************************************************************/

typedef struct {
  firm_kind kind;
  ident *name;
  /** needs list with it's entities -- does it really??
      Entities can be added during their creation.
  int n_members;
  entity **member; **/
  unsigned long visit;     /* visited counter for walks of the type information */
} type_strct;


/* create a new type_strct */
type_strct *new_type_strct (ident *name);

/* manipulate fields of type_strct */
char  *get_strct_name  (type_strct *strct);
ident *get_strct_ident (type_strct *strct);
/*
void   set_strct_name  (type_strct *strct, char *name);
void   set_strct_ident (type_strct *strct, ident* ident);
*/


/*******************************************************************/
/** TYPE_METHOD                                                   **/
/*******************************************************************/

typedef struct {
  firm_kind kind;
  ident *name;         /* do I need the name,
			  or is the name in entity sufficient?
			  No, there is no name for the type.  Types have
			  only names if typedef's give them one.  */
  int arity;           /* number of parameters, better n_params */
  type **param_type;   /* code generation needs this information.
                          Should it be generated by the frontend,
                          or does this impose unnecessary work for
                          optimizations that change the parameters of
                          methods? */
  int n_res;           /* number of results */
  type **res_type;
  /** needs pointer to it's ir_graph ??
  ir_graph *graph; **/
  unsigned long visit;     /* visited counter for walks of the type information */
} type_method;

/* create a new type_method */
type_method *new_type_method (ident *name, int arity, int n_res);

/* manipulate fields of type_method */

char  *get_method_name  (type_method *method);
ident *get_method_ident (type_method *method);
/* GL 9.2.2000: who commened these in?
   I think it's not safe to have these methods.
   Please add changes to Changes file.
void   set_method_name  (type_method *method, char *name);
void   set_method_ident (type_method *method, ident* ident); */

inline int   get_method_arity (type_method *method);
inline void  set_method_arity (type_method *method, int arity);
inline type *get_method_param_type(type_method *method, int pos);
inline void  set_method_param_type(type_method *method, int pos, type* type);

inline int   get_method_n_res (type_method *method);
inline void  set_method_n_res (type_method *method, int n_res);
inline type *get_method_res_type(type_method *method, int pos);
inline void  set_method_res_type(type_method *method, int pos, type* type);

/*
ir_graph *get_method_graph(type_method *method);
void *get_method_graph(type_method *method, ir_graph* graph);
*/

/*******************************************************************/
/** TYPE_UNION                                                    **/
/*******************************************************************/

typedef struct {
  firm_kind kind;
  ident *name;             /* do I need a name? */
  int n_types;
  /* type **unioned_type;    ... or something like that? */
  unsigned long visit;     /* visited counter for walks of the type information */
} type_union;

/* create a new type_union -- set unioned types by hand. */
type_union *new_type_union (ident *name, int n_types);

/* manipulate fields of type_union */
char  *get_union_name  (type_union *uni);
ident *get_union_ident (type_union *uni);
/*
void   set_union_name  (type_union *union, char *name);
void   set_union_ident (type_union *union, ident* ident);
*/
/*
int    get_union_n_types (type_union *union);
void   set_union_n_types (type_union *union, int n);
type  *get_union_unioned_type (type_union *union, int pos);
void   set_union_unioned_type (type_union *union, int pos, type *type);
*/

/*******************************************************************/
/** TYPE_ARRAY                                                    **/
/*******************************************************************/

/* multidimensional, polyhedric arrays */
typedef struct {
  firm_kind kind;
  ident *name;
  int n_dimensions;   /* Extend Sel to select from multidimensional arrays.  This  */
  int *lower_bound;   /* will allow to generate explicit array index computations  */
  int *upper_bound;   /* by replacing a single FIRM node.  As long as this is not
                         done create arrays with arrays as elements.  */
                      /* Should I use tarval? */
  type *element_type;
  unsigned long visit;     /* visited counter for walks of the type information */
} type_array;

/* create a new type array -- set dimension sizes independently */
type_array *new_type_array (ident *name, int n_dimensions);

/* manipulate fields of type_array */
char  *get_array_name  (type_array *array);
ident *get_array_ident (type_array *array);
/*
void   set_array_name  (type_array *array, char *name);
void   set_array_ident (type_array *array, ident* ident);
*/
void  set_array_n_dimensions  (type_array *array, int n);
int   get_array_n_dimensions  (type_array *array);

void  set_array_bounds      (type_array *array, int dimension, int lower_bound,
                                                              int upper_bound);
void  set_array_lower_bound (type_array *array, int dimension, int lower_bound);
void  set_array_upper_bound (type_array *array, int dimension, int upper_bound);
int   get_array_lower_bound (type_array *array, int dimension);
int   get_array_upper_bound (type_array *array, int dimension);

void  set_array_element_type (type_array *array, type *type);
type *get_array_element_type (type_array *array);

/*******************************************************************/
/** TYPE_ENUMERATION                                              **/
/*******************************************************************/
/** Enums are needed to keep debugging information.  They can as well
    be lowered to integers. **/

typedef struct {
  firm_kind kind;
  ident *name;
  /* int n_enums;
  ir_node **enum    * Contains all constant nodes that represent a member
                     of the enum -- enumerators. */
  /* is ir_node the propper array member? */
  unsigned long visit;     /* visited counter for walks of the type information */
} type_enumeration;

/* create a new type enumeration -- set the enumerators independently */
type_enumeration *new_type_enumeration (ident *name /* , int n_enums */);

/* manipulate fields of type_enumeration */
char  *get_enumeration_name  (type_enumeration *enumeration);
ident *get_enumeration_ident (type_enumeration *enumeration);
/*
void   set_enumeration_name  (type_enumeration *enumeration, char *name);
void   set_enumeration_ident (type_enumeration *enumeration, ident* ident);
*/
/*
void     set_enumeration_n_enums (type_enumeration *enumeration, int n);
int     *get_enumeration_n_enums (type_enumeration *enumeration);
void     set_enumeration_enum    (type_enumeration *enumeration, int pos,
                                 ir_node const);
ir_node *get_enumeration_enum    (type_enumeration *enumeration, int pos);
*/

/*******************************************************************/
/** TYPE_POINTER                                                  **/
/*******************************************************************/

typedef struct {
  firm_kind kind;
  ident *name;
  /* ir_mode *mode;      * The mode to be used for this type.
                            Not here as there might be several pointer types?
                            A method get_pointer_mode should read a unique,
                            global variable. */
  type *points_to;
  unsigned long visit;     /* visited counter for walks of the type information */
} type_pointer;

/* create a new type pointer */
type_pointer *new_type_pointer (ident *name, type *points_to);

/* manipulate fields of type_pointer */
char  *get_pointer_name  (type_pointer *pointer);
ident *get_pointer_ident (type_pointer *pointer);
/*
void   set_pointer_name  (type_pointer *pointer, char *name);
void   set_pointer_ident (type_pointer *pointer, ident* ident);
*/
void  set_pointer_points_to_type (type_pointer *pointer, type *type);
type *get_pointer_points_to_type (type_pointer *pointer);

/*******************************************************************/
/** TYPE_PRIMITIVE                                                **/
/*******************************************************************/

/* primitive, language-defined types */
/* What is the type of an entity if it is atomic?  Are alle basic data
   types classses in Sather? Else this is needed. */
typedef struct {
  firm_kind kind;
  ident *name;
  ir_mode *mode;       /* The mode to be used for this type */
  unsigned long visit;     /* visited counter for walks of the type information */
} type_primitive;

/* create a new type primitive */
type_primitive *new_type_primitive (ident *name, ir_mode *mode);

/* manipulate fields of type_primitive */
char  *get_primitive_name  (type_primitive *primitive);
ident *get_primitive_ident (type_primitive *primitive);
/*
void   set_primitive_name  (type_primitive *primitive, char *name);
void   set_primitive_ident (type_primitive *primitive, ident* ident);
*/
ir_mode *get_primitive_mode (type_primitive *primitive);
void     set_primitive_mode (type_primitive *primitive, ir_mode *mode);




/*******************************************************************/
/**  To manage all different types the same                       **/
/*******************************************************************/

union type {
  firm_kind kind;
  type_class clss;
  type_strct strct;
  type_method method;
  type_array array;
  type_union uni;  /* union is keyword */
  type_enumeration enumeration;
  type_pointer pointer;
  type_primitive primitive;
};

int is_type(void *thing);




# endif /* _TYPE_H_ */
